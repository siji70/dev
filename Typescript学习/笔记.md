# ts学习笔记
- ts适合在大型的项目中使用。

- TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。

- any类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。

- TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行

- "类型缩小"
```ts
    let un:unknow;
    if(typeof un === 'string'){
        un.substring(1)
    }else if(typeof un === 'number'){
        un.toFixed(2)
    }
    //例2
    function fn(s:string|number){
        if(typeof s === "string"){
            console.log(s.length);
        }else if(typeof s === "number"){
            console.log(s++);
        }else{
            console.log(s);  //never
        }
       // console.log(s.length);  //直接使用会报错
    }
```

- never
    - 它是ts类型中的"**底层类型**"，是所有类型的子类型，故有以下两个特性
    1. never不能给它赋任何类型的值，否则都会报错。
    ```ts
         let nev:never = 10;  //error 不能将类型number分配给类型never
         let nev:never = true;  //error 不能将类型boolean分配给类型never
         let nev:never = "abc";  //error 不能将类型string分配给类型never
    ```
    2. never类型的另一个重要特点是，可以赋值给任意其他类型。
    ```ts
        //never只在一些特殊的情况下出现，比如说：如果函数f()只会抛出错误，其返回值类型可以写成never等
         function f():never {
           throw new Error('Error');
         }
         let nn:number = f()
         let ss:string = f()
         let bb:boolean = f()
    ```


- 包装对象
    - 举个例子：String 就是 string 的包装对象，在js中包装对象有且只有String,Number,Boolean,Symbol,BigInt，五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即Symbol()和BigInt()不能作为构造函数使用），但是剩下三种可以。Boolean()，String()，Number()

- 大写类型（String）同时包含包装对象和字面量(string)两种情况，小写类型只包含字面量，不包含包装对象。
    - 建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。
    ```ts
        let a:String = 'abc'
        let aa:String = new String('abc')
        let aaa:string= 'abc'
        let aaaa:string= new String('abc') //error 不能将类型"String"分配给类型"string"
    ```
    - Symbol和BigInt这两个类型虽然存在，但是完全没有使用的理由

- 除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型。空对象{}是Object类型的简写形式，所以使用Object时常常用空对象代替。
```ts
    let b:Object = true 
    let bb:Object = 123
    let bbb:Object = 'abc'
    let c:{} = true 
    let cc:{} = 123
    let ccc:{} = 'abc'
    let bbbb:object = true //error 不能将类型"boolean"分配给类型"object"
```
- 注意，无论是大写的Object类型，还是小写的object类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。

- TypeScript 将typeof运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。同一段代码可能存在两种typeof运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。

- 类型推断的自动更新只发生初始值为空数组的情况。
```ts
    let arr=[]  //any[]
    arr.push(1)
    arr // number[]
    arr.push('1')
    arr // (string | number)[]
```
- 注意，readonly关键字不能与数组的泛型写法(xx:Array<number>)一起使用。
```ts
    const arr:readonly number[] =arr1
    const arr1:readonly Array<number>=[1]  //error 
```